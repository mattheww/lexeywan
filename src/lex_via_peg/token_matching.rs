//! Applies the Pest tokenisation grammar and represents data from the resulting matches.
//!
//! See tokenise.pest in this directory for the grammar itself.
//!
//! All Pest-specific code is isolated to this module, other than the Nonterminal enumeration.

use pest::{iterators::Pair, Parser, Span};

use crate::char_sequences::Charseq;
use crate::Edition;

/// Matches as much as possible using the specified edition's tokens nonterminal.
///
/// Reports an error message if it finds a problem in lex_via_peg's model or implementation.
pub fn match_tokens(edition: Edition, input: &[char]) -> Result<Outcome, String> {
    use {Multiplicity::*, Outcome::*};
    let s: String = input.iter().collect();
    let (tokens_rule, token_rule) = token_rules_for_edition(edition);
    let Ok(tokens_pairs) = TokenParser::parse(tokens_rule, &s) else {
        return Err("Pest reported no match of the tokens rule".to_owned());
    };
    let tokens_pair = extract_only_item(tokens_pairs).map_err(|m| match m {
        NoItems => "Pest reported empty response".to_owned(),
        Multiple => "Pest reported multiple top-level matches".to_owned(),
    })?;
    let matched_span = tokens_pair.as_span();
    let token_pairs = tokens_pair.into_inner();

    let mut matches = Vec::new();
    for token_pair in token_pairs {
        if token_pair.as_rule() != token_rule {
            return Err(format!(
                "Pest matched {:?} under the tokens rule",
                token_pair.as_rule()
            ));
        }
        let token_kind_pair = extract_only_item(token_pair.into_inner()).map_err(|m| match m {
            NoItems => "Pest reported empty match of the token rule".to_owned(),
            Multiple => "Pest reported multiple tokens under the token rule".to_owned(),
        })?;
        matches.push(MatchData::new(token_kind_pair));
    }
    Ok(if matched_span.end() == s.len() {
        Complete(matches)
    } else {
        Incomplete(matches)
    })
}

/// The result of attempting to match an edition's tokens nonterminal.
pub enum Outcome {
    /// The edition's TOKENS nonterminal matched the complete input.
    ///
    /// Each match of a token-kind nonterminal is represented in the MatchData.
    Complete(Vec<MatchData>),

    /// The edition's TOKENS nonterminal didn't match all the input.
    ///
    /// Each match of a token-kind nonterminal is represented in the MatchData.
    Incomplete(Vec<MatchData>),
}

#[derive(pest_derive::Parser)]
#[grammar = "lex_via_peg/tokenise.pest"]
/// Parser for the tokenisation grammar, generated by Pest.
struct TokenParser;

/// Enumeration of the nonterminals used in the tokenisation grammar.
///
/// This includes:
/// - the tokens nonterminals     (named like TOKENS_yyyy)
/// - the token nonterminals      (named like TOKEN_yyyy)
/// - the token-kind nonterminals (named in Title_case)
/// - subsidiary nonterminals     (named in UPPER_CASE)
///
/// Some members are nonterminals in the Pest grammar but documented as terminals in the writeup;
/// see [is_documented_as_terminal] below.
pub type Nonterminal = Rule;

/// Returns the Pest TOKENS and TOKEN rules to use for the specified Rust edition.
fn token_rules_for_edition(edition: Edition) -> (Rule, Rule) {
    match edition {
        Edition::E2015 => (Nonterminal::TOKENS_2015, Nonterminal::TOKEN_2015),
        Edition::E2021 => (Nonterminal::TOKENS_2021, Nonterminal::TOKEN_2021),
        Edition::E2024 => (Nonterminal::TOKENS_2024, Nonterminal::TOKEN_2024),
    }
}

/// Reports whether a nonterminal is documented as a terminal in the writeup.
fn is_documented_as_terminal(nt: Nonterminal) -> bool {
    // TAB is also documented as a terminal, but it only appears in the frontmatter grammar.
    nt == Nonterminal::DOUBLEQUOTE || nt == Nonterminal::BACKSLASH || nt == Nonterminal::LF
}

/// Information from a successful match of a token-kind nonterminal.
pub struct MatchData {
    /// The input characters which were consumed by the match.
    pub extent: Charseq,
    /// The token-kind nonterminal which participated in the match.
    pub token_kind_nonterminal: Nonterminal,
    /// The subsidiary nonterminals which participated in the match, the characters they consumed,
    /// and their spans inside the full match. Parent matches are listed before their descendents.
    /// Omits nonterminals which are documented as terminals.
    participating: Vec<(Nonterminal, Charseq, SubSpan)>,
}

impl std::fmt::Debug for MatchData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{:?} consuming {:?}",
            self.token_kind_nonterminal, self.extent
        )
    }
}

impl MatchData {
    /// Make a MatchData instance from the raw data provided by Pest.
    ///
    /// `pair`'s rule should be a token-kind nonterminal.
    fn new(pair: Pair<Nonterminal>) -> Self {
        Self {
            extent: pair.as_str().into(),
            token_kind_nonterminal: pair.as_rule(),
            participating: pair
                .into_inner()
                .flatten()
                .filter(|sub| !is_documented_as_terminal(sub.as_rule()))
                .map(|sub| (sub.as_rule(), sub.as_str().into(), sub.as_span().into()))
                .collect(),
        }
    }

    /// Returns the characters consumed by the specified subsidiary nonterminal, or None if that
    /// nonterminal did not participate in this match.
    ///
    /// Reports an error if that nonterminal participated in this match more than once.
    pub fn get_checked(&self, nonterminal: Nonterminal) -> Result<Option<&Charseq>, ()> {
        let mut found = None;
        for (candidate, consumed, _) in self.participating.iter() {
            if *candidate == nonterminal {
                match found {
                    Some(_) => {
                        return Err(());
                    }
                    None => {
                        found = Some(consumed);
                    }
                }
            }
        }
        Ok(found)
    }

    /// Returns the characters consumed by the outermost match of the specified subsidiary
    /// nonterminal, or None if that nonterminal did not participate in this match.
    ///
    /// If that nonterminal participated in this match more than once:
    /// - if all the sub-matches are nested inside one "outermost" sub-match, returns that
    ///   "outermost" sub-match's characters
    /// - otherwise reports an error.
    pub fn get_outermost(&self, nonterminal: Nonterminal) -> Result<Option<&Charseq>, ()> {
        let mut first_found_consumed = None;
        let mut first_found_span = None;
        for (candidate, consumed, span) in self.participating.iter() {
            if *candidate == nonterminal {
                match first_found_span {
                    Some(outermost_span) => {
                        if !span.is_inside(outermost_span) {
                            return Err(());
                        }
                    }
                    None => {
                        first_found_consumed = Some(consumed);
                        first_found_span = Some(span);
                    }
                }
            }
        }
        Ok(first_found_consumed)
    }

    /// Describes the subsidiary nonterminals making up this match, with their consumed extents.
    ///
    /// Omits nonterminals which are documented as terminals.
    pub fn describe_submatches(&self) -> impl Iterator<Item = String> + use<'_> {
        self.participating
            .iter()
            .map(|(rule, consumed, _)| format!("{rule:?} {consumed:?}"))
    }
}

/// Position information for sub-matches inside MatchData.
///
/// This is used to check whether the "outermost match" principle applies when there are multiple
/// matches for a nonterminal.
struct SubSpan {
    start: usize,
    end: usize,
}

impl SubSpan {
    /// Says whether this sub-match is properly nested inside `other`.
    ///
    /// This check is meaningful only if both `SubSpan`s came from the same `MatchData`.
    fn is_inside(&self, other: &SubSpan) -> bool {
        self.start >= other.start && self.end <= other.end
    }
}

impl From<Span<'_>> for SubSpan {
    fn from(span: Span) -> Self {
        Self {
            start: span.start(),
            end: span.end(),
        }
    }
}

/// Returns the only item from an iterator, or reports an error if it didn't have exactly one item.
fn extract_only_item<T>(mut stream: impl Iterator<Item = T>) -> Result<T, Multiplicity> {
    let Some(item) = stream.next() else {
        return Err(Multiplicity::NoItems);
    };
    let None = stream.next() else {
        return Err(Multiplicity::Multiple);
    };
    Ok(item)
}

enum Multiplicity {
    NoItems,
    Multiple,
}
